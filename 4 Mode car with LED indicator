#include <IRremote.h>  // Library for IR remote control
#include <Servo.h>     // Library for controlling servo motors
#include <Adafruit_NeoPixel.h>  // Library for controlling WS2812 LEDs

#define LED_PIN 4       // WS2812 DIN pin
#define NUM_LEDS 1      // Number of LEDs in the strip

Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);  // Initialize LED strip

// =================== MOTOR DRIVER PINS ===================
const int AIN1 = 7;   // Motor A control pin 1
const int AIN2 = 8;   // Motor A control pin 2
const int PWMA = 5;   // Motor A speed pin (PWM)
const int PWMB = 6;   // Motor B speed pin (PWM)
const int STANDBY = 3; // Motor driver standby pin

// =================== LINE SENSORS ========================
const int LINE_TRACKING_R = A0;  // Right line tracking sensor
const int LINE_TRACKING_M = A1;  // Middle line tracking sensor
const int LINE_TRACKING_L = A2;  // Left line tracking sensor

// =================== ULTRASONIC SENSOR ===================
const int trigPin = 13;  // Ultrasonic sensor trigger pin
const int echoPin = 12;  // Ultrasonic sensor echo pin
const int servoPin = 10; // Servo pin for ultrasonic scanning

// =================== Servo CONTROL ======================
Servo usServo;  // Servo object for ultrasonic scanning

// =================== SPEED CONTROL ======================
int speedValue = 80;           // Default speed
const int speedStep = 10;      // Step for increasing/decreasing speed
const int defaultVictoryLapSpeed = 120;  // Speed for victory lap

// =================== STATE MEMORY =======================
String lastDirection = "FORWARD";  // Last movement direction
bool isStopped = false;            // Flag for stop state

// =================== MODES ==============================
int currentMode = 0;  // Current mode: 0 = IR, 1 = Line Follow, 2 = Object Avoidance, 3 = Victory Lap

// =================== IR CODES ===========================
#define FORWARD_CODE    0xB946FF00
#define RIGHT_CODE      0xBC43FF00
#define LEFT_CODE       0xBB44FF00
#define BACKWARD_CODE   0xEA15FF00
#define SPEED_UP_CODE   0xF708FF00
#define SPEED_DOWN_CODE 0xA55AFF00
#define STOP_CODE       0xBF40FF00
#define MODE_BUTTON     0xBD42FF00

// =================== THRESHOLDS ========================
const int LINE_THRESHOLD = 500;  // Threshold for line detection
const int AIR_THRESHOLD  = 900;  // Threshold for detecting “in-air” (lost line)
const int SAFE_DISTANCE  = 30;   // Minimum safe distance for object avoidance (cm)

// =================== FUNCTION PROTOTYPES ================
void Mode_IR();
void Mode_LineFollow();
void Mode_ObjectAvoidance();
bool handleIR();
void Forward(byte speed);
void Backward(byte speed);
void Left(byte speed);
void Right(byte speed);
void Stop();
void applyLastDirection();
void VictoryLap();
void runSegmentForward(int speed, unsigned long duration);
void runSegmentRight(int speed, unsigned long duration);
void searchForLine();
bool readLineSensors();
int measureAt(int angle);
int getDistance();
void setModeColor(int mode);  // Set RGB LED color according to mode

// =================== SETUP =============================
void setup() {
  Serial.begin(9600);  // Initialize serial monitor

  // Motor driver pin setup
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(STANDBY, OUTPUT);
  digitalWrite(STANDBY, HIGH);  // Activate motor driver

  // Line sensor pin setup
  pinMode(LINE_TRACKING_R, INPUT);
  pinMode(LINE_TRACKING_M, INPUT);
  pinMode(LINE_TRACKING_L, INPUT);

  // Ultrasonic sensor pin setup
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  // Attach servo for ultrasonic scanning
  usServo.attach(servoPin);
  usServo.write(90);  // Initialize at center
  delay(500);

  // Initialize IR receiver
  IrReceiver.begin(9, ENABLE_LED_FEEDBACK);

  // Initialize LED strip
  strip.begin();
  strip.show();  // Turn off LED initially
  strip.setPixelColor(0, strip.Color(0, 0, 255)); // Default mode 0 = Blue
  strip.show();
  setModeColor(currentMode);  // Set LED color for current mode

  Serial.println("IR + Line Follow + Object Avoidance + Victory Lap Ready");
}

// =================== LOOP ==============================
void loop() {
  // Main loop selects behavior according to current mode
  switch (currentMode) {
    case 0:
      Mode_IR();  // Remote control mode
      break;
    case 1:
      Mode_LineFollow();  // Line following mode
      break;
    case 2:
      Mode_ObjectAvoidance();  // Obstacle avoidance mode
      break;
    case 3:
      VictoryLap();  // Pre-programmed victory lap
      break;
  }
}

// =================== MOTOR FUNCTIONS ===================
// Forward movement
void Forward(byte speed) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, HIGH);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Backward movement
void Backward(byte speed) {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, LOW);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Turn left
void Left(byte speed) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Turn right
void Right(byte speed) {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, HIGH);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Stop motors
void Stop() {
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
  digitalWrite(STANDBY, HIGH);
}

// Apply last stored direction (used after speed change)
void applyLastDirection() {
  if (isStopped) return;
  if (lastDirection == "FORWARD") Forward(speedValue);
  else if (lastDirection == "BACKWARD") Backward(speedValue);
  else if (lastDirection == "LEFT") Left(speedValue);
  else if (lastDirection == "RIGHT") Right(speedValue);
}

// =================== UNIVERSAL IR HANDLER ==============
bool handleIR() {
  if (!IrReceiver.decode()) return false;  // No IR signal
  unsigned long code = IrReceiver.decodedIRData.decodedRawData;
  IrReceiver.resume();

  if (code == 0x0) return false;  // Ignore null codes
  if (IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT) return false;  // Ignore repeat signals

  // STOP command
  if (code == STOP_CODE) {
    Stop();
    isStopped = true;
    Serial.println("STOP LOCK ACTIVATED");
    return true;
  }

  // MODE change button
  if (code == MODE_BUTTON) {
    currentMode = (currentMode + 1) % 4;
    Stop();
    isStopped = true;
    if (currentMode == 1) speedValue = 65;
    else speedValue = 80;
    Serial.print("Switched to Mode: ");
    if (currentMode == 0) Serial.println("IR");
    else if (currentMode == 1) Serial.println("Line Follow");
    else if (currentMode == 2) Serial.println("Object Avoidance");
    else if (currentMode == 3) Serial.println("Victory Lap");
    setModeColor(currentMode);  // Change LED color
    delay(300);
    return true;
  }

  // Movement commands
  if (code == FORWARD_CODE || code == BACKWARD_CODE || code == LEFT_CODE || code == RIGHT_CODE) {
    isStopped = false;
    switch (code) {
      case FORWARD_CODE: Forward(speedValue); lastDirection = "FORWARD"; break;
      case BACKWARD_CODE: Backward(speedValue); lastDirection = "BACKWARD"; break;
      case LEFT_CODE: Left(speedValue); lastDirection = "LEFT"; break;
      case RIGHT_CODE: Right(speedValue); lastDirection = "RIGHT"; break;
    }
    return true;
  }

  // Speed adjustment
  if (code == SPEED_UP_CODE) { speedValue += speedStep; if (speedValue > 255) speedValue = 255; applyLastDirection(); return true; }
  if (code == SPEED_DOWN_CODE) { speedValue -= speedStep; if (speedValue < 0) speedValue = 0; applyLastDirection(); return true; }

  return false;
}

// =================== VICTORY LAP ===================
void runSegmentForward(int speed, unsigned long duration) {
  unsigned long start = millis();
  while (millis() - start < duration) {
    if (handleIR()) {
      if (isStopped || currentMode != 3) {
        Stop();
        return;
      }
    }
    Forward(speed);
  }
  Stop();
}

void VictoryLap() {
  // Pre-programmed sequence of movements
  Forward(80); delay(11750); Stop(); delay(1000);
  Right(100); delay(680); Stop(); delay(1000);
  Forward(80); delay(6350); Stop(); delay(1000);
  Right(100); delay(680); Stop(); delay(1000);
  Forward(80); delay(11750); Stop(); delay(1000);
  Right(100); delay(680); Stop(); delay(1000);
  Forward(80); delay(6350); Stop(); delay(1000);
  Right(100); delay(680); Stop(); delay(1000);
  currentMode = 0;  // Return to IR mode
  Stop();
}

// =================== LINE FOLLOW FUNCTIONS =============
bool readLineSensors() {
  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);
  return (L > LINE_THRESHOLD || M > LINE_THRESHOLD || R > LINE_THRESHOLD);
}

// Search for lost line by wiggle movements
void searchForLine() {
  byte wiggleSpeed = speedValue * 0.4;
  if (lastDirection == "RIGHT") Right(wiggleSpeed);
  else if (lastDirection == "LEFT") Left(wiggleSpeed);
  else {Right(wiggleSpeed); delay(150); Left(wiggleSpeed); delay(150); }

  if (!readLineSensors()) {
    if (lastDirection == "RIGHT") { Right(speedValue * 0.6); delay(500); }
    else if (lastDirection == "LEFT") { Left(speedValue * 0.6); delay(250); }
    else { Right(speedValue * 0.6); delay(500); Left(speedValue * 0.6); delay(350); }
  }

  if (!readLineSensors()) {
    if (lastDirection == "RIGHT") { Right(speedValue * 0.6); delay(1000); }
    else if (lastDirection == "LEFT") { Left(speedValue * 0.6); delay(500); }
    else { Right(speedValue * 0.6); delay(1000); Left(speedValue * 0.6); delay(600); }
  }

  if (!readLineSensors()) {
    Backward(40); delay(400);
  }

  Stop();
}

// Line follow mode
void Mode_LineFollow() {
  if (handleIR()) return;  // Handle remote commands

  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);

  if (L > AIR_THRESHOLD && M > AIR_THRESHOLD && R > AIR_THRESHOLD) {
    Stop();
    isStopped = true;
    Serial.println("In-air detected -> STOP");
    return;
  }

  if (isStopped) { Stop(); return; }

  bool leftBlack   = L > LINE_THRESHOLD;
  bool middleBlack = M > LINE_THRESHOLD;
  bool rightBlack  = R > LINE_THRESHOLD;

  if (middleBlack) Forward(60);
  else if (leftBlack) Left(speedValue);
  else if (rightBlack) Right(speedValue);
  else searchForLine();

  delay(50);
}

// =================== IR MODE ===========================
void Mode_IR() {
  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);

  if (L > AIR_THRESHOLD && M > AIR_THRESHOLD && R > AIR_THRESHOLD) {
    Stop();
    isStopped = true;
    Serial.println("In-air detected -> STOP");
    return;
  }

  handleIR();  // Handle remote commands
}

// =================== OBJECT AVOIDANCE ==================
int measureAt(int angle) {
  usServo.write(angle);  // Rotate servo
  delay(1000);
  return getDistance();
}

// Measure distance with ultrasonic sensor
int getDistance() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH, 20000);  // Max 20ms timeout
  int distance = duration * 0.034 / 2;
  if (distance == 0 || distance > 300) distance = 300;
  return distance;
}

// Object avoidance mode
void Mode_ObjectAvoidance() {
  if (handleIR()) return;

  int distanceForward = measureAt(90);  // Check forward
  if (distanceForward > SAFE_DISTANCE) { Forward(speedValue); return; }

  Stop(); delay(200);

  int distanceLeft = measureAt(160);
  usServo.write(90); delay(300);
  if (distanceLeft > SAFE_DISTANCE) { Left(speedValue); delay(780); Stop(); return; }

  int distanceRight = measureAt(20);
  usServo.write(90); delay(300);
  if (distanceRight > SAFE_DISTANCE) { Right(speedValue); delay(780); Stop(); return; }

  Left(speedValue); delay(1300); Stop();
}

// =================== COLOR RGB ==================
void setModeColor(int mode) {
  uint32_t color;
  switch(mode) {
    case 0: color = strip.Color(0, 0, 255); break;     // IR → Blue
    case 1: color = strip.Color(0, 255, 0); break;     // Line Follow → Green
    case 2: color = strip.Color(255, 255, 0); break;   // Object Avoidance → Yellow
    case 3: color = strip.Color(255, 0, 0); break;     // Victory Lap → Red
    default: color = strip.Color(0, 0, 0); break;      // Off
  }
  strip.setPixelColor(0, color);
  strip.show();
}
