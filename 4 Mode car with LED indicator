// Include necessary libraries
#include <IRremote.h>       // Library to receive IR remote signals
#include <Servo.h>          // Library to control servo motors
#include <Adafruit_NeoPixel.h> // Library for controlling WS2812 (NeoPixel) LEDs

// =================== LED SETUP ===================
#define LED_PIN 4       // WS2812 data input pin
#define NUM_LEDS 1      // Number of WS2812 LEDs

// Initialize the NeoPixel strip
Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

// =================== MOTOR DRIVER PINS ===================
const int AIN1 = 7;      // Motor A input 1
const int AIN2 = 8;      // Motor A input 2
const int PWMA = 5;      // Motor A PWM speed control
const int PWMB = 6;      // Motor B PWM speed control
const int STANDBY = 3;   // Motor driver standby pin

// =================== LINE TRACKING SENSORS ===================
const int LINE_TRACKING_R = A0; // Right line sensor
const int LINE_TRACKING_M = A1; // Middle line sensor
const int LINE_TRACKING_L = A2; // Left line sensor

// =================== ULTRASONIC SENSOR PINS ===================
const int trigPin = 13;  // Trigger pin for ultrasonic sensor
const int echoPin = 12;  // Echo pin for ultrasonic sensor
const int servoPin = 10; // Servo motor pin for ultrasonic scanning

// =================== SERVO ===================
Servo usServo;            // Servo for ultrasonic sensor

// =================== SPEED CONTROL ===================
int speedValue = 80;         // Default speed for motors
const int speedStep = 10;    // Increment/decrement step for speed
const int defaultVictoryLapSpeed = 120; // Speed during Victory Lap mode

// =================== STATE MEMORY ===================
String lastDirection = "FORWARD"; // Last motor direction
bool isStopped = false;           // Flag to indicate if robot is stopped

// =================== MODES ===================
int currentMode = 0;  // Robot modes: 0 = IR, 1 = Line Follow, 2 = Object Avoidance, 3 = Victory Lap

// =================== IR CODES ===================
#define FORWARD_CODE    0xB946FF00
#define RIGHT_CODE      0xBC43FF00
#define LEFT_CODE       0xBB44FF00
#define BACKWARD_CODE   0xEA15FF00
#define SPEED_UP_CODE   0xF708FF00
#define SPEED_DOWN_CODE 0xA55AFF00
#define STOP_CODE       0xBF40FF00
#define MODE_BUTTON     0xBD42FF00

// =================== THRESHOLDS ===================
const int LINE_THRESHOLD = 500;   // Threshold for line sensor to detect black line
const int AIR_THRESHOLD  = 900;   // Threshold for detecting in-air condition (no surface)
const int SAFE_DISTANCE  = 30;    // Minimum safe distance in cm for object avoidance

// =================== FUNCTION PROTOTYPES ===================
void Mode_IR();
void Mode_LineFollow();
void Mode_ObjectAvoidance();
bool handleIR();
void Forward(byte speed);
void Backward(byte speed);
void Left(byte speed);
void Right(byte speed);
void Stop();
void applyLastDirection();
void VictoryLap();
void runSegmentForward(int speed, unsigned long duration);
void runSegmentRight(int speed, unsigned long duration);
void searchForLine();
bool readLineSensors();
int measureAt(int angle);
int getDistance();
void setModeColor(int mode);  

// =================== SETUP ===================
void setup() {
  Serial.begin(9600);  // Initialize serial communication for debugging

  // Motor pins setup
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(STANDBY, OUTPUT);
  digitalWrite(STANDBY, HIGH); // Enable motor driver

  // Line sensors setup
  pinMode(LINE_TRACKING_R, INPUT);
  pinMode(LINE_TRACKING_M, INPUT);
  pinMode(LINE_TRACKING_L, INPUT);

  // Ultrasonic sensor setup
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  // Attach servo for ultrasonic scanning
  usServo.attach(servoPin);
  usServo.write(90); // Center position
  delay(500);

  // Initialize IR receiver
  IrReceiver.begin(9, ENABLE_LED_FEEDBACK);

  // Initialize LED strip
  strip.begin();
  strip.show(); // Turn off initially
  strip.setPixelColor(0, strip.Color(0, 0, 255)); // Default mode = Blue
  strip.show();
  setModeColor(currentMode);

  Serial.println("IR + Line Follow + Object Avoidance + Victory Lap Ready");
}

// =================== MAIN LOOP ===================
void loop() {
  switch (currentMode) {
    case 0: Mode_IR(); break;
    case 1: Mode_LineFollow(); break;
    case 2: Mode_ObjectAvoidance(); break;
    case 3: VictoryLap(); break;
  }
}

// =================== MOTOR CONTROL FUNCTIONS ===================

// Move forward
void Forward(byte speed) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, HIGH);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Move backward
void Backward(byte speed) {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, LOW);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Turn left
void Left(byte speed) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Turn right
void Right(byte speed) {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, HIGH);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
  digitalWrite(STANDBY, HIGH);
}

// Stop motors
void Stop() {
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
  digitalWrite(STANDBY, HIGH);
}

// Apply last known direction (used after speed change)
void applyLastDirection() {
  if (isStopped) return;

  if (lastDirection == "FORWARD") Forward(speedValue);
  else if (lastDirection == "BACKWARD") Backward(speedValue);
  else if (lastDirection == "LEFT") Left(speedValue);
  else if (lastDirection == "RIGHT") Right(speedValue);
}

// =================== UNIVERSAL IR HANDLER ===================
bool handleIR() {
  if (!IrReceiver.decode()) return false; // No IR signal detected

  unsigned long code = IrReceiver.decodedIRData.decodedRawData; // Get IR code
  IrReceiver.resume(); // Prepare for next IR signal

  if (code == 0x0) return false; // Invalid code
  if (IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT) return false; // Ignore repeat codes

  // STOP command
  if (code == STOP_CODE) {
    Stop();
    isStopped = true;
    Serial.println("STOP LOCK ACTIVATED");
    return true;
  }

  // Mode change button
  if (code == MODE_BUTTON) {
    currentMode = (currentMode + 1) % 4; // Cycle modes
    Stop();
    isStopped = true;

    if (currentMode == 1) speedValue = 65; // Slower for line following
    else speedValue = 80;

    // Debug messages
    Serial.print("Switched to Mode: ");
    if (currentMode == 0) Serial.println("IR");
    else if (currentMode == 1) Serial.println("Line Follow");
    else if (currentMode == 2) Serial.println("Object Avoidance");
    else if (currentMode == 3) Serial.println("Victory Lap");

    setModeColor(currentMode); // Update LED color
    delay(300);
    return true;
  }

  // Directional commands
  if (code == FORWARD_CODE || code == BACKWARD_CODE || code == LEFT_CODE || code == RIGHT_CODE) {
    isStopped = false;
    switch (code) {
      case FORWARD_CODE: Forward(speedValue); lastDirection = "FORWARD"; break;
      case BACKWARD_CODE: Backward(speedValue); lastDirection = "BACKWARD"; break;
      case LEFT_CODE: Left(speedValue); lastDirection = "LEFT"; break;
      case RIGHT_CODE: Right(speedValue); lastDirection = "RIGHT"; break;
    }
    return true;
  }

  // Speed control
  if (code == SPEED_UP_CODE) { speedValue += speedStep; if (speedValue > 255) speedValue = 255; applyLastDirection(); return true; }
  if (code == SPEED_DOWN_CODE) { speedValue -= speedStep; if (speedValue < 0) speedValue = 0; applyLastDirection(); return true; }

  return false;
}

// =================== VICTORY LAP ===================
void VictoryLap() {
  // Predefined movement sequence for victory lap
  Forward(80); delay(11750); Stop(); delay(1000);
  Right(100); delay(430); Stop(); delay(1000);
  Forward(80); delay(6350); Stop(); delay(1000);
  Right(100); delay(430); Stop(); delay(1000);
  Forward(80); delay(11750); Stop(); delay(1000);
  Right(100); delay(430); Stop(); delay(1000);
  Forward(80); delay(6350); Stop(); delay(1000);
  Right(100); delay(430); Stop(); delay(1000);

  currentMode = 0; // Return to IR mode after lap
  Stop();
}

// =================== LINE FOLLOW FUNCTIONS ===================
bool readLineSensors() {
  // Returns true if any sensor detects the line
  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);
  return (L > LINE_THRESHOLD || M > LINE_THRESHOLD || R > LINE_THRESHOLD);
}

void searchForLine() {
  // Wiggle to find line when lost
  byte wiggleSpeed = speedValue * 0.4;

  if (lastDirection == "RIGHT") Right(wiggleSpeed);
  else if (lastDirection == "LEFT") Left(wiggleSpeed);
  else {Right(wiggleSpeed); delay(150); Left(wiggleSpeed); delay(150); }

  if (!readLineSensors()) {
    if (lastDirection == "RIGHT") { Right(speedValue * 0.6); delay(500); }
    else if (lastDirection == "LEFT") { Left(speedValue * 0.6); delay(250); }
    else { Right(speedValue * 0.6); delay(500); Left(speedValue * 0.6); delay(350); }
  }

  if (!readLineSensors()) {
    if (lastDirection == "RIGHT") { Right(speedValue * 0.6); delay(1000); }
    else if (lastDirection == "LEFT") { Left(speedValue * 0.6); delay(500); }
    else { Right(speedValue * 0.6); delay(1000); Left(speedValue * 0.6); delay(600); }
  }

  if (!readLineSensors()) {
    Backward(40); delay(400); // Move backward if line not found
  }

  Stop();
}

void Mode_LineFollow() {
  if (handleIR()) return; // Handle IR inputs

  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);

  // Stop if robot is in air
  if (L > AIR_THRESHOLD && M > AIR_THRESHOLD && R > AIR_THRESHOLD) {
    Stop();
    isStopped = true;
    Serial.println("In-air detected -> STOP");
    return;
  }

  if (isStopped) { Stop(); return; }

  bool leftBlack   = L > LINE_THRESHOLD;
  bool middleBlack = M > LINE_THRESHOLD;
  bool rightBlack  = R > LINE_THRESHOLD;

  // Follow line based on sensor readings
  if (middleBlack) Forward(60);
  else if (leftBlack) Left(speedValue);
  else if (rightBlack) Right(speedValue);
  else searchForLine();

  delay(50); // Small delay for stability
}

// =================== IR MODE ===================
void Mode_IR() {
  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);

  // Stop if robot is in air
  if (L > AIR_THRESHOLD && M > AIR_THRESHOLD && R > AIR_THRESHOLD) {
    Stop();
    isStopped = true;
    Serial.println("In-air detected -> STOP");
    return;
  }

  handleIR(); // Handle IR remote commands
}

// =================== OBJECT AVOIDANCE ===================
int measureAt(int angle) {
  usServo.write(angle); // Rotate servo
  delay(1000);
  return getDistance(); // Measure distance
}

int getDistance() {
  // Trigger ultrasonic sensor and calculate distance
  digitalWrite(trigPin, LOW); delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH, 20000);
  int distance = duration * 0.034 / 2;
  if (distance == 0 || distance > 300) distance = 300;
  return distance;
}

void Mode_ObjectAvoidance() {
  if (handleIR()) return; // Handle IR input

  int distanceForward = measureAt(90);
  if (distanceForward > SAFE_DISTANCE) { Forward(speedValue); return; }

  Stop(); delay(200);

  int distanceLeft = measureAt(160);
  usServo.write(90); delay(300);
  if (distanceLeft > SAFE_DISTANCE) { Left(speedValue); delay(780); Stop(); return; }

  int distanceRight = measureAt(20);
  usServo.write(90); delay(300);
  if (distanceRight > SAFE_DISTANCE) { Right(speedValue); delay(780); Stop(); return; }

  // If all sides blocked, turn left
  Left(speedValue); delay(1300); Stop();
}

// =================== LED MODE COLORS ===================
void setModeColor(int mode) {
  uint32_t color;
  switch(mode) {
    case 0: color = strip.Color(0, 0, 255); break;     // IR → Blue
    case 1: color = strip.Color(0, 255, 0); break;     // Line Follow → Green
    case 2: color = strip.Color(255, 255, 0); break;   // Object Avoidance → Yellow
    case 3: color = strip.Color(255, 0, 0); break;     // Victory Lap → Red
    default: color = strip.Color(0, 0, 0); break;      // Off
  }
  strip.setPixelColor(0, color);
  strip.show();
}
