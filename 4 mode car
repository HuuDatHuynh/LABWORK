#include <IRremote.h>
#include <Servo.h>

// =================== MOTOR DRIVER PINS ===================
const int AIN1 = 7;
const int AIN2 = 8;
const int PWMA = 5;
const int PWMB = 6;
const int STANDBY = 3;

// =================== LINE SENSORS ========================
const int LINE_TRACKING_R = A0;
const int LINE_TRACKING_M = A1;
const int LINE_TRACKING_L = A2;

// =================== ULTRASONIC SENSOR ===================
const int trigPin = 13;
const int echoPin = 12;
const int servoPin = 10;

Servo usServo;

// =================== SPEED CONTROL ======================
int speedValue = 80;
const int speedStep = 10;

// =================== STATE MEMORY =======================
String lastDirection = "FORWARD";
bool isStopped = false;

// =================== MODES ==============================
int currentMode = 0;  // 0 = IR, 1 = Line Follow, 2 = Object Avoidance, 3 = Victory Lap

// =================== IR CODES ===========================
#define FORWARD_CODE    0xB946FF00
#define RIGHT_CODE      0xBC43FF00
#define LEFT_CODE       0xBB44FF00
#define BACKWARD_CODE   0xEA15FF00
#define SPEED_UP_CODE   0xF708FF00
#define SPEED_DOWN_CODE 0xA55AFF00
#define STOP_CODE       0xBF40FF00
#define MODE_BUTTON     0xBD42FF00

// =================== THRESHOLDS ========================
const int LINE_THRESHOLD = 500;
const int AIR_THRESHOLD  = 900;
const int SAFE_DISTANCE  = 30;

// =================== SETUP =============================
void setup() {
  Serial.begin(9600);

  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(STANDBY, OUTPUT);
  digitalWrite(STANDBY, HIGH);

  pinMode(LINE_TRACKING_R, INPUT);
  pinMode(LINE_TRACKING_M, INPUT);
  pinMode(LINE_TRACKING_L, INPUT);

  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  usServo.attach(servoPin);
  usServo.write(90);
  delay(500);

  IrReceiver.begin(9, ENABLE_LED_FEEDBACK);

  Serial.println("IR + Line Follow + Object Avoidance + Victory Lap Ready");
}

// =================== LOOP ==============================
void loop() {

  switch (currentMode) {
    case 0: Mode_IR(); break;
    case 1: Mode_LineFollow(); break;
    case 2: Mode_ObjectAvoidance(); break;
    case 3: VictoryLap(); break;
  }

}

// =================== UNIVERSAL IR HANDLER ==============
bool handleIR() {
  if (!IrReceiver.decode()) return false;

  unsigned long code = IrReceiver.decodedIRData.decodedRawData;
  IrReceiver.resume();
  if (code == 0x0) return false;
  if (IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT) return false;

  if (code == STOP_CODE) {
    Stop();
    isStopped = true;
    Serial.println("STOP LOCK ACTIVATED");
    return true;
  }

  if (code == MODE_BUTTON) {
    currentMode = (currentMode + 1) % 4;  // *** NOW 4 MODES ***
    Stop();
    isStopped = true;

    if (currentMode == 1) speedValue = 60;
    else speedValue = 80;

    Serial.print("Switched to Mode: ");
    if (currentMode == 0) Serial.println("IR");
    else if (currentMode == 1) Serial.println("Line Follow");
    else if (currentMode == 2) Serial.println("Object Avoidance");
    else if (currentMode == 3) Serial.println("Victory Lap");

    delay(300);
    return true;
  }

  if (code == FORWARD_CODE || code == BACKWARD_CODE || code == LEFT_CODE || code == RIGHT_CODE) {
    isStopped = false;

    switch (code) {
      case FORWARD_CODE:  Forward(speedValue); lastDirection = "FORWARD"; break;
      case BACKWARD_CODE: Backward(speedValue); lastDirection = "BACKWARD"; break;
      case LEFT_CODE:     Left(speedValue); lastDirection = "LEFT"; break;
      case RIGHT_CODE:    Right(speedValue); lastDirection = "RIGHT"; break;
    }

    return true;
  }

  if (code == SPEED_UP_CODE) {
    speedValue += speedStep; if (speedValue > 255) speedValue = 255;
    applyLastDirection();
    return true;
  }

  if (code == SPEED_DOWN_CODE) {
    speedValue -= speedStep; if (speedValue < 0) speedValue = 0;
    applyLastDirection();
    return true;
  }

  return false;
}

// =================== IR MODE ===========================
void Mode_IR() {
  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);

  if (L > AIR_THRESHOLD && M > AIR_THRESHOLD && R > AIR_THRESHOLD) {
    Stop();
    isStopped = true;
    Serial.println("In-air detected -> STOP");
    return;
  }

  handleIR();
}

// =================== LINE FOLLOW =======================
bool readLineSensors();
void searchForLine();

void Mode_LineFollow() {
  if (handleIR()) return;

  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);

  if (L > AIR_THRESHOLD && M > AIR_THRESHOLD && R > AIR_THRESHOLD) {
    Stop();
    isStopped = true;
    Serial.println("In-air detected -> STOP");
    return;
  }

  if (isStopped) { Stop(); return; }

  bool leftBlack   = L > LINE_THRESHOLD;
  bool middleBlack = M > LINE_THRESHOLD;
  bool rightBlack  = R > LINE_THRESHOLD;

  if (middleBlack) Forward(speedValue);
  else if (leftBlack) Left(speedValue);
  else if (rightBlack) Right(speedValue);
  else searchForLine();

  delay(50);
}

// =================== LINE FOLLOW HELPERS =================
bool readLineSensors() {
  int L = analogRead(LINE_TRACKING_L);
  int M = analogRead(LINE_TRACKING_M);
  int R = analogRead(LINE_TRACKING_R);
  return (L > LINE_THRESHOLD || M > LINE_THRESHOLD || R > LINE_THRESHOLD);
}

void searchForLine() {
  byte wiggleSpeed = speedValue * 0.4;

  if (lastDirection == "LEFT") Left(wiggleSpeed);
  else if (lastDirection == "RIGHT") Right(wiggleSpeed);
  else { Left(wiggleSpeed); delay(150); Right(wiggleSpeed); delay(150); }

  if (!readLineSensors()) {
    if (lastDirection == "LEFT") { Left(speedValue * 0.6); delay(250); }
    else if (lastDirection == "RIGHT") { Right(speedValue * 0.6); delay(250); }
    else { Left(speedValue * 0.6); delay(250); Right(speedValue * 0.6); delay(250); }
  }

  if (!readLineSensors()) {
    if (lastDirection == "LEFT") { Left(speedValue * 0.6); delay(500); }
    else if (lastDirection == "RIGHT") { Right(speedValue * 0.6); delay(500); }
    else { Left(speedValue * 0.6); delay(500); Right(speedValue * 0.6); delay(500); }
  }

  if (!readLineSensors()) {
    Backward(speedValue);
    delay(600);
  }

  Stop();
}

// =================== OBJECT AVOIDANCE ===================
int getDistance();
int measureAt(int angle);

void Mode_ObjectAvoidance() {

    if (handleIR()) return;

    int distanceForward = measureAt(90);

    if (distanceForward > SAFE_DISTANCE) {
        Forward(speedValue);
        return;
    }

    Stop();
    delay(200);

    int distanceLeft = measureAt(160);
    usServo.write(90);
    delay(300);

    if (distanceLeft > SAFE_DISTANCE) {
        Left(speedValue);
        delay(400);
        Stop();
        return;
    }

    int distanceRight = measureAt(20);
    usServo.write(90);
    delay(300);

    if (distanceRight > SAFE_DISTANCE) {
        Right(speedValue);
        delay(400);
        Stop();
        return;
    }

    Left(speedValue);
    delay(1300);
    Stop();
}

// =================== VICTORY LAP MODE ===================
void VictoryLap() {

  if (handleIR()) {
    if (isStopped || currentMode != 3) {
      Stop();
      return;
    }
  }

  Serial.println("Starting Victory Lap!");

  Forward(200);
  delay(4300);
  Stop();
  delay(1000);

  Right(100);
  delay(500);
  Stop();
  delay(1000);

  Forward(200);
  delay(2500);
  Stop();
  delay(1000);

  Right(100);
  delay(500);
  Stop();
  delay(1000);

  Forward(200);
  delay(4300);
  Stop();
  delay(1000);

  Right(100);
  delay(500);
  Stop();
  delay(1000);

  Forward(200);
  delay(2500);
  Stop();
  delay(1000);

  Right(100);
  delay(500);
  Stop();
  delay(1000);

  Serial.println("Victory Lap Complete!");

  currentMode = 0;
  Stop();
}

// ===================MEASURE ANGLE=============  
int measureAt(int angle) {
  usServo.write(angle);
  delay(1000);
  return getDistance();
}

// ===================DISTANCE==================
int getDistance() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH, 20000);
  int distance = duration * 0.034 / 2;

  if (distance == 0 || distance > 300) distance = 300;

  return distance;
}

// =================== HELPER ===========================
void applyLastDirection() {
  if (isStopped) return;

  if (lastDirection == "FORWARD") Forward(speedValue);
  else if (lastDirection == "BACKWARD") Backward(speedValue);
  else if (lastDirection == "LEFT") Left(speedValue);
  else if (lastDirection == "RIGHT") Right(speedValue);
}

// =================== MOTOR FUNCTIONS ===================
void Forward(byte speed) {
  digitalWrite(AIN1,HIGH);
  digitalWrite(AIN2,HIGH);
  analogWrite(PWMA,speed);
  analogWrite(PWMB,speed);
  digitalWrite(STANDBY,HIGH);
}

void Backward(byte speed){
  digitalWrite(AIN1,LOW);
  digitalWrite(AIN2,LOW);
  analogWrite(PWMA,speed);
  analogWrite(PWMB,speed);
  digitalWrite(STANDBY,HIGH);
}

void Left(byte speed){
  digitalWrite(AIN1,HIGH);
  digitalWrite(AIN2,LOW);
  analogWrite(PWMA,speed);
  analogWrite(PWMB,speed);
  digitalWrite(STANDBY,HIGH);
}

void Right(byte speed){
  digitalWrite(AIN1,LOW);
  digitalWrite(AIN2,HIGH);
  analogWrite(PWMA,speed);
  analogWrite(PWMB,speed);
  digitalWrite(STANDBY,HIGH);
}

void Stop(){
  analogWrite(PWMA,0);
  analogWrite(PWMB,0);
  digitalWrite(STANDBY,HIGH);
}
